Java五子棋人机对弈程序 (Five-in-a-Row with AI)

这是一个基于 Java Swing 实现的五子棋人机对弈程序。项目从一个简单的课程设计作业出发，旨在通过不断的技术迭代和功能优化，探索一个基础项目逐步走向复杂的演进过程。
📖 项目背景

这个项目的诞生，源于一次与学长的对话。当时我认为学校的Java大作业略显基础，而学长一席话点醒了我：“很多复杂的商业项目，其核心原型可能都非常简单，比如亚马逊的本质也是一个信息管理系统。它的强大在于后续为了应对真实世界的挑战，一步步引入了数据库、分布式、搜索引擎、推荐算法等一系列复杂的优化。”

受此启发，我决定将这个五子棋项目作为一个起点，在完成基本功能后，持续对其进行优化，并记录下我的思考与迭代过程。这个GitHub仓库就是这一过程的见证。
✨ 当前已实现功能

    图形化对弈界面: 基于 Java Swing 构建，提供了一个标准的15x15棋盘，并实现了美观的UI和流畅的用户交互体验。
    基础游戏逻辑: 实现了完整的下棋、轮换、边界判断等核心游戏规则。
    高效的胜负判断: 采用高效算法，在每次落子后仅对当前棋子周围的四个方向（横、竖、双斜线）进行判断，避免了对全棋盘的低效扫描。
    智能AI对手机器人:
        告别随机算法：AI已经不是简单的随机落子。
        核心算法：实现了一套基于评估函数 (Evaluation Function) 的决策模型。AI会遍历棋盘上的所有空位，通过计算每个位置的“进攻分”（为自己构建有利棋形）和“防守分”（阻止对手形成有利棋形），最终选择综合得分最高的点进行落子。
        棋形识别：能够识别并评估包括活四、冲四、活三、眠三、活二等多种关键棋形，从而具备了不错的攻防能力。

🛠️ 核心技术栈与实现细节

    前端界面: Java Swing (JFrame, JPanel)
    核心绘图: 重写 paintComponent 方法，使用 Graphics2D 进行棋盘和棋子的自定义绘制，并开启了抗锯齿以优化视觉效果。
    事件处理: 通过 MouseListener 监听用户的鼠标点击事件，并将其转换为棋盘坐标，实现了实时响应。
    AI决策模型:
        评估函数: 项目的核心亮点。通过“线性扫描与字符串匹配”的方式，将一个位置在四个方向上的棋形“切片”转换为字符串，再与预设的棋形模式库进行比对，从而实现对一个位置战略价值的量化评估。
        攻防一体: 对每个待选位置都会同时计算进攻分与防守分，使得AI在自我发展和限制对手之间做出权衡。
    设计模式: 整体架构采纳了逻辑与视图分离的思想（准MVC模式），将游戏规则和AI算法封装在 GameLogic 类中，将界面显示和用户交互放在 GameUI 类中，使得代码结构清晰，易于维护和升级。

🚀 如何运行

    确保您的环境中已安装 JDK (1.8或更高版本)。
    将项目克隆或下载到本地。
    使用IDE（如 IntelliJ IDEA, Eclipse）打开项目，或者在项目根目录下使用命令行：
    Bash

    # 编译所有 .java 文件
    javac *.java

    # 运行主程序
    java Run

    程序将启动，您可以开始与AI进行对弈。

🗺️ 未来优化路线图 (Roadmap)

这个项目对我而言是一个持续学习和实践的平台。根据我最初的构想，后续计划探索以下优化方向：

    [ ] AI算法进阶:
        引入Minimax博弈树算法，让AI具备向后预判几步棋的能力。
        结合 Alpha-Beta剪枝 算法，在不牺牲棋力的前提下，大幅提升搜索效率。
    [ ] 实现联机对战:
        学习并引入Java Socket网络编程和多线程技术，实现一个C/S（客户端/服务器）架构，让两名玩家可以通过网络进行对战。
    [ ] 跨语言技术探索:
        尝试使用 JNI (Java Native Interface) 或进程间通信 (IPC) 的方式，调用我学习过的 C++ 渲染技术（如OpenGL或SDL）来绘制棋盘，探索Java与其他语言混合编程的实践。
